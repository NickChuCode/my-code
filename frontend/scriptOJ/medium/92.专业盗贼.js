// 你是一个盗窃专家，某一天晚上你要去盗窃某一条街道的一排房子。这些房子都有相连的防盗系统，如果你把相邻的两家都偷了那么就会触发报警器。
//
// 用一个数组来表示这些房子的金钱数量，请你完成 rob 函数，计算出在不触发报警器的情况下最多能偷多少钱。例如：
//
// rob([1, 2, 3]) // => 4

// 解题思路：这是一个动态规划问题，比如你要选择是否偷i家，如果要偷，则你需要偷i - 2家；
// 如果不偷，则问题转换为偷i - 1家的最大值
const rob = (nums) => {
    var n = nums.length
    var totalNums = []
    totalNums[0] = 0
    totalNums[1] = nums[0]
    totalNums[2] = maxTotal(nums[0], nums[1])
    for (var i = 3; i < n + 1; i++) {
        // 注意：这里totalNums里的i表示偷前i家的最大值，而nums中第i家的索引是i - 1
        totalNums[i] = maxTotal(totalNums[i - 2] + nums[i - 1], totalNums[i - 1])
    }
    return totalNums[n]
}

function maxTotal(left, right) {
    return left > right ? left : right
}

// 简单的动态规划问题, 主要在于状态转移.
//
// 每个房子能否偷取决于前一个房子是否被偷过. 当我们想知道i个房子最多能偷多少钱时, 可以分为两种情况:
//
// 如果想偷房子i, 需要知道不偷i - 1时前i - 1个房子最多能偷多少, 也就是偷前i - 2个. 知道偷前i - 2个最多偷多少,
// 然后加上第i个房子的钱数, 就是偷i时最多的钱数.
// 如果不偷i, 那最多的钱数就是偷前i - 1个房子能偷到的最多的钱.
// 保留两种情况的更优解, 就是i个房子最多能偷到多少钱的答案.
//
// 因此我们可以通过i - 2和i - 1个房子的最优解推i个房子的最优解, 当我们知道i = 0和i = 1是的解时(都是显而易见的答案), 就可以依次往后推导了.